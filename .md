# **1Ô∏è‚É£ Imports ‚Äì What we bring into the code**

```python
import tkinter as tk
from tkinter import messagebox, ttk
from decimal import Decimal, InvalidOperation
from datetime import date, datetime, timedelta
import mysql.connector
import matplotlib.pyplot as plt
import calendar
```

### Explanation:

* **`tkinter`** ‚Üí the main Python library to create windows, buttons, labels, and GUI apps. We call it `tk` to make it shorter.
* **`messagebox`** ‚Üí pop-up messages like **Error**, **Success**, or **Info**.
* **`ttk`** ‚Üí styled widgets like **dropdown menus** (`Combobox`) or **tables** (`Treeview`).
* **`Decimal`** ‚Üí used to store money precisely (normal floats can be slightly wrong, like 0.1+0.2 ‚â† 0.3 exactly).
* **`InvalidOperation`** ‚Üí catches errors if a number conversion fails (like entering letters instead of money).
* **`date, datetime, timedelta`** ‚Üí working with dates, like today‚Äôs date, or checking last day of month.
* **`mysql.connector`** ‚Üí connect Python to a **MySQL database**.
* **`matplotlib.pyplot`** ‚Üí draw **charts** (like pie charts for your finances).
* **`calendar`** ‚Üí helps check **month details** like how many days are in February.

---

# **2Ô∏è‚É£ Database Connection**

```python
db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="Radha9959",
    database="fingo"
)
cur = db.cursor()
```

### Explanation:

* Connects Python to **MySQL database called `fingo`**.
* **`cur`** ‚Üí a cursor, which is used to **execute SQL commands** like SELECT, INSERT, UPDATE.
* Any time you want to **get data** or **save data**, you use `cur.execute()`.
* **Important detail:** after changing data, you must call `db.commit()` to **save changes** permanently.

---

# **3Ô∏è‚É£ Default Categories**

```python
DEFAULT_CATEGORIES = [
    "Job","Food", "Transport", "Education", "Entertainment", "Shopping",
    "Health", "Savings", "Travel", "Bills", "Other"
]
```

* These are **predefined categories** for transactions and goals.
* Used in dropdowns for **user-friendly selection**.
* Helps to **organize expenses** (like ‚ÄúFood‚Äù, ‚ÄúTravel‚Äù, etc.).

---

# **4Ô∏è‚É£ Calculate Totals**

```python
def calc_totals(user):
    cur.execute("SELECT SUM(amount) FROM transactions WHERE username=%s AND type='income'", (user,))
    inc = cur.fetchone()[0] or 0
    cur.execute("SELECT SUM(amount) FROM transactions WHERE username=%s AND type='expense'", (user,))
    exp = cur.fetchone()[0] or 0
    cur.execute("SELECT SUM(amount) FROM transactions WHERE username=%s AND type='savings'", (user,))
    sav = cur.fetchone()[0] or 0
    return Decimal(inc), Decimal(exp), Decimal(sav)
```

### Explanation:

* This **function calculates total money** for a user:

  1. Total income
  2. Total expenses
  3. Total savings
* **`%s` in SQL** ‚Üí a placeholder to safely insert values (prevents SQL injection).
* `(user,)` ‚Üí the comma is **important**. It makes it a **tuple** (Python needs a tuple for one value). Without the comma, it‚Äôs just a string.
* **`fetchone()[0]`** ‚Üí gets the first column of the first row from database query result.
* **`or 0`** ‚Üí if there are no records, return 0 instead of `None`.
* `Decimal(...)` ‚Üí ensures **precise calculations** for money.

---

# **5Ô∏è‚É£ Date and Money Helpers**

### Last Day of Month

```python
def is_last_day_of_month(d: date):
    return d.day == calendar.monthrange(d.year, d.month)[1]
```

* Checks if a date `d` is the **last day of its month**.
* `calendar.monthrange(year, month)[1]` ‚Üí returns **number of days in month**.

### Money Formatting

```python
def money_label(amount):
    return f"‚Çπ{amount:,.2f}"
```

* Converts number into **currency format**, e.g., 1234 ‚Üí `‚Çπ1,234.00`.
* **`,.2f`** ‚Üí adds commas and 2 decimal points.

---

# **6Ô∏è‚É£ Pie Chart Helper**

```python
def pie_autopct_factory(sizes):
    total = sum(sizes)
    def my_autopct(pct):
        val = pct / 100.0 * total
        return f"‚Çπ{val:,.2f}"
    return my_autopct
```

* Converts **percentage in a pie chart** to **actual ‚Çπ value**.
* Example: 40% of ‚Çπ1000 ‚Üí shows ‚Çπ400 on the chart.

---

# **7Ô∏è‚É£ Register Function**

```python
def register():
    username = entry_user.get().strip()
    password = entry_pass.get().strip()

    if not username or not password:
        messagebox.showerror("Error", "Enter username and password!")
        return

    cur.execute("SELECT username FROM users WHERE username=%s", (username,))
    if cur.fetchone():
        messagebox.showerror("Error", "Username already exists!")
        return

    cur.execute("INSERT INTO users VALUES (%s, %s)", (username, password))
    db.commit()
    messagebox.showinfo("Success", "Registered successfully!")
```

### Explanation:

1. Gets **username** and **password** from user input.
2. `.strip()` ‚Üí removes extra spaces.
3. Checks if either is empty ‚Üí shows **error message**.
4. Checks if username already exists ‚Üí prevents duplicates.
5. Inserts new user into **users table** in database.
6. `db.commit()` ‚Üí saves changes.
7. Shows **success pop-up**.

---

# **8Ô∏è‚É£ Login Function**

```python
def login():
    username = entry_user.get().strip()
    password = entry_pass.get().strip()
    cur.execute("SELECT * FROM users WHERE username=%s AND password=%s", (username, password))
    if cur.fetchone():
        open_dashboard(username)
    else:
        messagebox.showerror("Error", "Invalid credentials!")
```

* Checks **username and password** in the database.
* If correct ‚Üí opens dashboard.
* If wrong ‚Üí shows error.

---

# **9Ô∏è‚É£ Open Dashboard**

```python
def open_dashboard(user):
    app.withdraw()
    dash = tk.Toplevel(app)
    dash.title(f"FinGo Dashboard - {user}")
    dash.geometry("700x450")
```

* `app.withdraw()` ‚Üí hides login window.
* `Toplevel(app)` ‚Üí creates new **dashboard window**.
* Sets **title** and **size**.

---

### **9a. Display Totals and Balance**

```python
inc, exp, sav = calc_totals(user)
balance = inc - (exp + sav)
tk.Label(dash, text=f"Welcome, {user}", font=("Arial", 16, "bold")).pack(pady=8)
```

* Gets **income, expense, savings**.
* Calculates **balance** = income ‚àí (expense + savings).
* Shows **welcome message**.

```python
frame_info = tk.Frame(dash)
frame_info.pack(pady=4)
lbl_income = tk.Label(frame_info, text=f"Income: {money_label(inc)}")
lbl_income.grid(row=0, column=0, sticky="w")
lbl_expense = tk.Label(frame_info, text=f"Expense: {money_label(exp)}")
lbl_expense.grid(row=1, column=0, sticky="w")
lbl_savings = tk.Label(frame_info, text=f"Savings: {money_label(sav)}")
lbl_savings.grid(row=2, column=0, sticky="w")
```

* Uses **Frame** ‚Üí groups labels neatly.
* `grid()` ‚Üí positions labels in table form.
* `sticky="w"` ‚Üí aligns text to left.

```python
lbl_balance = tk.Label(dash, text=f"Present Balance: {money_label(balance)}",font=("Arial", 14, "bold"), fg="Dark Green")
lbl_balance.pack(pady=8)
```

* Shows **balance in green**.

---

### **9b. Buttons**

```python
btn_frame = tk.Frame(dash)
btn_frame.pack(pady=6)
tk.Button(btn_frame, text="Add Transaction", width=22, command=lambda: add_trans(user, refresh)).grid(row=0, column=0)
tk.Button(btn_frame, text="Add Goal", width=22, command=lambda: add_goal(user, refresh)).grid(row=0, column=1)
tk.Button(btn_frame, text="Add Savings to Goal", width=22, command=lambda: add_savings_to_goal(user, refresh)).grid(row=1, column=0)
tk.Button(btn_frame, text="Show Transactions", width=22, command=lambda: show_transactions(user)).grid(row=1, column=1)
tk.Button(btn_frame, text="Show Summary (Pie Chart)", width=22, command=lambda: show_summary(user)).grid(row=2, column=0)
tk.Button(btn_frame, text="Show Goals (Pie Charts)", width=22, command=lambda: show_goals(user)).grid(row=2, column=1)
```

* **6 buttons** for dashboard actions:

  1. Add Transaction
  2. Add Goal
  3. Add Savings to Goal
  4. Show Transactions
  5. Show Summary (Pie chart)
  6. Show Goals (Pie chart)
* `lambda:` ‚Üí passes **user and refresh function**.

---

### **9c. Logout and Goals Section**

```python
tk.Button(dash, text="Logout", width=18, command=lambda: [dash.destroy(), app.deiconify()]).pack(pady=14)
tk.Label(dash, text="Goals:", font=("Arial", 12, "bold")).pack(pady=(6, 0))
goals_frame = tk.Frame(dash)
goals_frame.pack(padx=6, pady=4, fill="x")
```

* Logout ‚Üí destroys dashboard and shows login window again.
* `goals_frame` ‚Üí container for displaying goals dynamically.

---

### **9d. Load Goals**

```python
def load_goals():
    for w in goals_frame.winfo_children():
        w.destroy()
    cur.execute("SELECT name, target, saved FROM goals WHERE username=%s", (user,))
    rows = cur.fetchall()
    if not rows:
        tk.Label(goals_frame, text="No goals yet").pack(anchor="w")
    else:
        for name, target, saved in rows:
            perc = (saved / target * 100) if target > 0 else 0
            tk.Label(goals_frame, text=f"{name} ‚Äî ‚Çπ{saved}/{target} ({perc:.0f}%)").pack(anchor="w")
```

* Clears old widgets in `goals_frame`.
* Fetches goals from DB.
* Shows **goal name, saved, target, % completion**.

---

### **9e. Refresh Dashboard**

```python
def refresh():
    nonlocal lbl_income, lbl_expense, lbl_savings, lbl_balance
    i, e, s = calc_totals(user)
    lbl_income.config(text=f"Income: {money_label(i)}")
    lbl_expense.config(text=f"Expense: {money_label(e)}")
    lbl_savings.config(text=f"Savings: {money_label(s)}")
    lbl_balance.config(text=f"Present Balance: {money_label(i - (e + s))}")
    load_goals()
```

* Updates totals and goals after any **transaction or goal change**.
* `nonlocal` ‚Üí allows us to update labels outside this function.

---

# **10Ô∏è‚É£ Add Transaction Window**

```python
win = tk.Toplevel(app)
win.title("Add Transaction")
win.geometry("700x450")
```

* Opens **new transaction window**.

```python
t = ttk.Combobox(win, values=["income", "expense", "savings"], state="readonly")
t.set("expense"); t.pack()
c = ttk.Combobox(win, values=DEFAULT_CATEGORIES, state="readonly")
c.set(DEFAULT_CATEGORIES[0]); c.pack()
a = tk.Entry(win); a.pack()
n = tk.Entry(win); n.pack()
```

* Dropdown for **type** (income/expense/savings).
* Dropdown for **category**.
* Entry for **amount**.
* Entry for **note**.

```python
def save():
    try:
        amt = Decimal(a.get())
        if amt <= 0: raise InvalidOperation
    except:
        messagebox.showerror("Error", "Enter a valid amount")
        return
```

* Converts **amount** to `Decimal`.
* Checks **positive number**.
* Shows error if invalid.

```python
cur.execute("""
    INSERT INTO transactions(username, type, category, amount, note, date)
    VALUES (%s, %s, %s, %s, %s, %s)
""", (user, t.get(), c.get(), amt, n.get().strip(), date.today()))
db.commit()
```

* Saves transaction to database.

```python
messagebox.showinfo("Success", "Transaction added!")
win.destroy()
on_done()
```

* Shows success ‚Üí closes window ‚Üí refresh dashboard.


# **11Ô∏è‚É£ Add Goal (`add_goal`)**

### Function definition

```python
def add_goal(user, on_done):
```

### What this means in simple words

* This function is called **when user clicks ‚ÄúAdd Goal‚Äù button**
* It receives:

  * `user` ‚Üí current logged-in username
  * `on_done` ‚Üí a function (usually `refresh`) that updates dashboard after saving

üëâ Passing `on_done` is **very important**, because the dashboard must update after adding a goal.

---

### Create a new window

```python
win = tk.Toplevel(app)
win.title("Add Goal")
win.geometry("700x450")
```

#### Explanation

* `Toplevel(app)` ‚Üí creates a **new window on top of dashboard**
* This window is **independent**, but still belongs to the main app
* Title shows at top
* Geometry defines window size

So now user sees a **new ‚ÄúAdd Goal‚Äù window**.

---

### Goal name input

```python
tk.Label(win, text="Goal Name").pack(pady=4)
name = tk.Entry(win)
name.pack()
```

#### Explanation

* Label tells user **what to enter**
* `Entry` is a text box
* `pack(pady=4)` ‚Üí adds small vertical space so UI looks neat

At this point:

* User types something like:
  **‚ÄúNew Laptop‚Äù**

---

### Target amount input

```python
tk.Label(win, text="Target Amount").pack(pady=4)
target = tk.Entry(win)
target.pack()
```

#### Explanation

* This is the **total money required** for the goal
* Example:

  * Laptop ‚Üí ‚Çπ60,000
* Entry box stores data as **string**, not number
* We will convert it later

---

### Category selection

```python
tk.Label(win, text="Category").pack(pady=4)
cat = ttk.Combobox(win, values=DEFAULT_CATEGORIES, state="readonly")
cat.set(DEFAULT_CATEGORIES[0])
cat.pack()
```

#### Explanation

* Category helps **organize goals**
* `Combobox` ‚Üí dropdown menu
* `state="readonly"` ‚Üí user **cannot type random text**
* They must select from given categories
* Default value is first category

This prevents **wrong input**.

---

## **11aÔ∏è‚É£ Save function inside Add Goal**

This function runs **only when user clicks ‚ÄúSave‚Äù button**.

---

### Convert and validate target amount

```python
def save():
    try:
        targ = Decimal(target.get())
        if targ <= 0:
            raise InvalidOperation
```

#### Deep explanation

* `target.get()` ‚Üí gets text from entry box (string)
* `Decimal(...)` ‚Üí converts string to **money-safe number**
* Why not `float`?

  * Float can give wrong results
  * Money needs accuracy

Example:

```
Decimal("0.1") + Decimal("0.2") = 0.3 ‚úî
float(0.1) + float(0.2) ‚â† 0.3 ‚ùå
```

* `if targ <= 0`:

  * Goal amount must be **positive**
  * 0 or negative makes no sense

---

### Handle invalid input

```python
    except:
        messagebox.showerror("Error", "Invalid target amount")
        return
```

#### Explanation

* If user enters:

  * letters
  * empty input
  * negative number
* Code jumps to `except`
* Shows error popup
* `return` stops function

So **nothing is saved** if input is wrong.

---

### Insert goal into database

```python
cur.execute("""
    INSERT INTO goals(username, name, target, saved, category)
    VALUES (%s, %s, %s, %s, %s)
""", (user, name.get().strip() or "Unnamed", targ, 0, cat.get()))
db.commit()
```

#### Very important explanation (slowly)

* This saves goal into **MySQL `goals` table**
* Values meaning:

  * `username` ‚Üí owner of goal
  * `name` ‚Üí goal name
  * `target` ‚Üí total required amount
  * `saved` ‚Üí initially **0**
  * `category` ‚Üí selected category

##### Why `name.get().strip() or "Unnamed"`?

* `strip()` removes extra spaces
* If user leaves name empty:

  * `""` is False
  * So `"Unnamed"` is used

This avoids **empty goal names**.

---

### Why `(user, ...)` has a comma?

Example:

```python
(user,)
```

* Python requires **tuple** for SQL values
* Single value tuple **must have comma**
* Without comma ‚Üí Python thinks it‚Äôs just a string

‚úî Correct:

```python
(user,)
```

‚ùå Wrong:

```python
(user)
```

---

### Save changes permanently

```python
db.commit()
```

* Without this ‚Üí data is **not saved**
* Think of it like:

  > ‚ÄúConfirm and save to disk‚Äù

---

### Success message and refresh

```python
messagebox.showinfo("Success", "Goal added!")
win.destroy()
on_done()
```

#### Explanation

* Shows success popup
* Closes add-goal window
* Calls `on_done()` ‚Üí refresh dashboard:

  * updates goals list
  * updates balance

---

### Save button

```python
tk.Button(win, text="Save", command=save).pack(pady=10)
```

* Button click ‚Üí runs `save()`
* This connects **UI ‚Üí logic ‚Üí database**

---

# **12Ô∏è‚É£ Add Savings to Goal (`add_savings_to_goal`)**

This feature allows:

> ‚ÄúI already have a goal, now add money to it‚Äù

---

### Fetch goals first

```python
def add_savings_to_goal(user, on_done):
  cur.execute("SELECT id, name FROM goals WHERE username=%s", (user,))
  rows = cur.fetchall()
```

#### Explanation

* Gets **all goals of current user**
* Each row contains:

  * `id` ‚Üí unique number
  * `name` ‚Üí goal name

---

### If no goals exist

```python
if not rows:
    messagebox.showinfo("Info", "No goals available")
    return
```

* No goals ‚Üí nothing to add savings to
* So function stops early

---

### Open Add Savings window

```python
win = tk.Toplevel(app)
win.title("Add Savings to Goal")
win.geometry("700x450")
```

* New window opens

---

### Goal selection dropdown

```python
names = [r[1] for r in rows]
```

* Extracts only **goal names** from DB rows

```python
tk.Label(win, text="Choose Goal").pack(pady=6)
box = ttk.Combobox(win, values=names, state="readonly")
box.set(names[0])
box.pack()
```

* Dropdown shows goal names
* User selects one goal

---

### Amount entry

```python
tk.Label(win, text="Amount to Add").pack(pady=6)
amt = tk.Entry(win)
amt.pack()
```

* User enters how much money to add

---

## **12aÔ∏è‚É£ Save savings logic**

### Validate amount

```python
def save():
    try:
        amount = Decimal(amt.get())
        if amount <= 0:
            raise InvalidOperation
```

* Same money validation logic
* Ensures positive number

---

### Find selected goal ID

```python
goal = [r for r in rows if r[1] == box.get()][0]
goal_id = goal[0]
```

#### Explanation

* `rows` contains `(id, name)`
* We match selected name
* Extract its ID
* ID is used in database updates

---

### Update goal savings

```python
cur.execute(
    "UPDATE goals SET saved = saved + %s WHERE id=%s",
    (amount, goal_id)
)
db.commit()
```

* Adds amount to existing saved value
* Example:

  * saved = 1000
  * add 500
  * new saved = 1500

---

### Record this as a transaction

```python
cur.execute("""
INSERT INTO transactions(username, type, category, amount, note, date)
VALUES (%s,'savings',(SELECT category FROM goals WHERE id=%s),%s,%s,%s)
""", (user, goal_id, amount, f"ToGoal:{box.get()}", date.today()))
db.commit()
```

#### Why this is important

* Even savings are **financial transactions**
* Keeps full history
* Category automatically comes from goal
* Note clearly says:

  ```
  ToGoal:Laptop
  ```

---

### Check if goal is completed

```python
cur.execute("SELECT target, saved FROM goals WHERE id=%s", (goal_id,))
target, saved = cur.fetchone()
```

* Gets updated values

```python
if saved >= target:
    messagebox.showinfo("Goal Completed", f"Goal '{box.get()}' completed üéâ")
    cur.execute("DELETE FROM goals WHERE id=%s", (goal_id,))
    db.commit()
```

#### Logic

* If saved money reached target:

  * Celebrate üéâ
  * Remove goal from active goals
* Goal is **completed**, not deleted history

---

### Close and refresh

```python
win.destroy()
on_done()
```

* Closes window
* Refreshes dashboard

---

# **13Ô∏è‚É£ Show Transactions**

### Window creation

```python
def show_transactions(user):
  win = tk.Toplevel(app)
  win.title("All Transactions")
  win.geometry("700x450")
```

---

### Create table (Treeview)

```python
table = ttk.Treeview(
    win,
    columns=("type", "category", "amount", "note", "date"),
    show="headings",
    height=15
)
```

* `Treeview` acts like **Excel table**
* `show="headings"` ‚Üí only column names

---

### Table formatting

```python
table.column("amount", width=110, anchor="e")
```

* Amount aligned to **right**
* Looks professional

---

### Load data

```python
cur.execute(
    "SELECT type, category, amount, note, date FROM transactions WHERE username=%s",
    (user,)
)
```

```python
for t in cur.fetchall():
    table.insert("", "end",
        values=(t[0], t[1], money_label(t[2]), t[3], t[4])
    )
```

* Reads all transactions
* Formats amount as ‚Çπ
* Inserts row by row

---

# **14Ô∏è‚É£ Show Summary (Pie Chart)**

### Calculate totals

```python
def show_summary(user):
  inc, exp, sav = calc_totals(user)
  sizes = [float(inc), float(exp + sav)]
```

* Income vs (Expense + Savings)

---

### No data check

```python
if sum(sizes) == 0:
    messagebox.showinfo("Info", "No data to show")
    return
```

* Prevents empty chart

---

### Draw pie chart

```python
fig, ax = plt.subplots(figsize=(6, 6))
ax.pie(
    sizes,
    labels=["Total Income", "Expense + Savings"],
    autopct=pie_autopct_factory(sizes),
    startangle=90
)
plt.show()
```

* Visual summary of money flow




# **15Ô∏è‚É£ Show goals (Pie Chart)**

This function is called **when user clicks ‚ÄúShow Goals (Pie Charts)‚Äù** on the dashboard.

Its job is:

> **Show visual progress of each goal using pie charts**

---

### Function definition

```python
def show_goals(user):
```

* `user` ‚Üí currently logged-in username
* This ensures **only that user‚Äôs goals** are shown

---

### Fetch goals from database

```python
cur.execute(
    "SELECT name, target, saved FROM goals WHERE username=%s",
    (user,)
)
rows = cur.fetchall()
```

#### Explanation (very important)

* This SQL query asks:

  > ‚ÄúGive me all goals belonging to this user‚Äù
* We select:

  * `name` ‚Üí goal name (Laptop, Bike, etc.)
  * `target` ‚Üí total amount needed
  * `saved` ‚Üí amount already saved

#### Why `(user,)` has a comma?

* MySQL connector expects a **tuple**
* Single value tuple **must end with a comma**
* `(user,)` ‚úî
* `(user)` ‚ùå (just a string)

---

### Check if goals exist

```python
if not rows:
    messagebox.showinfo("Info", "No goals available")
    return
```

#### Explanation

* If user has **no goals**:

  * `rows` is empty list `[]`
* Show friendly popup
* `return` stops function
* Prevents empty charts

---

### Loop through each goal

```python
for name, target, saved in rows:
```

#### Explanation

* Each `row` contains:

  * `name`
  * `target`
  * `saved`
* Loop runs **once per goal**
* Example:

  * Goal 1: Laptop
  * Goal 2: Bike
* Each goal gets **its own chart**

---

### Calculate remaining amount

```python
remaining = target - saved
```

#### Logic

* If target = 50,000
* Saved = 18,000
* Remaining = 32,000

This shows **how much is still needed**

---

### Prepare data for pie chart

```python
sizes = [float(saved), float(max(remaining, 0))]
```

#### Deep explanation

* Pie chart needs **numbers**
* Matplotlib works best with `float`
* We convert `Decimal` ‚Üí `float`

#### Why `max(remaining, 0)`?

* Prevents **negative values**
* Example:

  * Saved > Target (due to rounding or late update)
* Pie chart **cannot draw negative slices**
* So we safely clamp it to 0

---

### Create pie chart figure

```python
fig, ax = plt.subplots(figsize=(5, 5))
```

#### Explanation

* Creates a **new chart window**
* `fig` ‚Üí whole figure
* `ax` ‚Üí drawing area
* `figsize=(5,5)` ‚Üí square chart

---

### Draw the pie chart

```python
ax.pie(
    sizes,
    labels=["Saved", "Remaining"],
    autopct=pie_autopct_factory(sizes),
    startangle=90
)
```

#### Explanation in simple words

* `sizes` ‚Üí actual values (saved, remaining)
* `labels` ‚Üí text shown beside slices
* `autopct`:

  * Converts percentage into **‚Çπ amount**
  * Uses your helper function
* `startangle=90`:

  * Starts pie from top
  * Looks visually balanced

---

### Set chart title

```python
ax.set_title(name)
```

* Title = **goal name**
* Example:

  * Laptop
  * Bike

---

### Display chart

```python
plt.show()
```

* Opens the pie chart window
* Each goal opens **one chart**
* User closes chart to see next one


---

##  Main App (Login Window)

This is the **starting point of the entire application**.

Nothing runs before this visually.

---

### Create root window

```python
app = tk.Tk()
```

#### Explanation

* `Tk()` creates the **main application window**
* There must be **only ONE Tk()**
* All other windows use `Toplevel`

Think of this as:

> **Mother window of the whole app**

---

### Set window title and size

```python
app.title("FinGo Login")
app.geometry("700x450")
```

* Title shows in top bar
* Geometry defines width √ó height

---

### App heading label

```python
tk.Label(
    app,
    text="FinGo App",
    font=("Menlo", 18, "bold")
).pack(pady=10)
```

#### Explanation

* Displays **app name**
* Bigger font
* `pady=10` ‚Üí space above and below

---

### Username label and input

```python
tk.Label(app, text="Username").pack()
entry_user = tk.Entry(app)
entry_user.pack()
```

#### Explanation

* Label tells user what to enter
* Entry box collects username
* Stored later using:

  ```python
  entry_user.get()
  ```

---

### Password label and input

```python
tk.Label(app, text="Password").pack()
entry_pass = tk.Entry(app, show="*")
entry_pass.pack()
```

#### Explanation

* Password field
* `show="*"`:

  * Hides typed characters
  * Security & privacy

---

### Login button

```python
tk.Button(
    app,
    text="Login",
    width=20,
    command=login
).pack(pady=6)
```

#### Explanation

* When clicked:

  * Calls `login()` function
* `login()`:

  * Checks DB
  * Opens dashboard if correct
* Width makes UI look clean

---

### Register button

```python
tk.Button(
    app,
    text="Register",
    width=20,
    command=register
).pack()
```

#### Explanation

* Calls `register()` function
* Creates new user in database

---

### Start event loop

```python
app.mainloop()
```

#### MOST IMPORTANT LINE

* Starts **GUI event loop**
* Program waits for:

  * Button clicks
  * Text input
  * Window actions
* Without this:

  * App opens and closes immediately



